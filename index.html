<!DOCTYPE html />
<html>
<head>
	<title>Focco.fs</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="focco.css" rel="stylesheet" media="all" type="text/css" />
	<script src="prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
			<div id="jump_to">
				Jump To &hellip;
				<div id="jump_wrapper">
					<div id="jump_page">
							<a class="source" href="assemblyinfo.html">
								AssemblyInfo.fs
							</a>
							<a class="source" href="index.html">
								Focco.fs
							</a>
					</div>
				</div>
			</div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>Focco.fs</h1>
					</th>
					<th class="code"></th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							<p><strong>Focco</strong> is a quick-and-dirty, literate-programming-style documentation
generator. It is a F# port of <a href="http://dontangg.github.com/nocco/">Nocco</a>
by <a href="https://github.com/dontangg/">Don Wilson</a>,
which in turn is a port of <a href="http://jashkenas.github.com/docco/">Docco</a> for .NET,
which was written by <a href="https://github.com/jashkenas">Jeremy Ashkenas</a> in
Coffescript and runs on node.js.</p>

<p>Focco produces HTML that displays your comments alongside your code.
Comments are passed through
<a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a>, and code is
highlighted using <a href="http://code.google.com/p/google-code-prettify/">google-code-prettify</a>
syntax highlighting. This page is the result of running Focco against its
own source files.</p>

<p>Currently, to build Focco, you'll have to have .NET 4.0 and <a href="http://github.com/fsharp/fsharp">F# 2.0</a>.
The project depends on
<a href="http://code.google.com/p/markdownsharp/">MarkdownSharp</a> and
<a href="http://razorengine.codeplex.com/">RazorEngine</a> (for the System.Web.Razor assembly).</p>

<p>To use Focco, run it from the command-line:</p>

<pre><code>focco *.fs
</code></pre>

<p>...will generate linked HTML documentation for the named source files, saving
it into a <code>docs</code> folder.</p>

<p>The <a href="http://github.com/panesofglass/focco">source for Focco</a> is available on GitHub, and released under the MIT license.
The <a href="http://github.com/dontangg/nocco">original source in C#</a> is also available on GitHub.</p>

<p>If <strong>.NET</strong> doesn't run on your platform, or you'd prefer a more convenient
package, get <a href="http://rtomayko.github.com/rocco/">Rocco</a>, the Ruby port that's
available as a gem. If you're writing shell scripts, try
<a href="http://rtomayko.github.com/shocco/">Shocco</a>, a port for the <strong>POSIX shell</strong>.
Both are by <a href="http://github.com/rtomayko">Ryan Tomayko</a>. If Python's more
your speed, take a look at <a href="http://github.com/fitzgen">Nick Fitzgerald</a>'s
<a href="http://fitzgen.github.com/pycco/">Pycco</a>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>module Focco =

</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<p>Import namespaces to allow us to type shorter type names.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  open System
  open System.CodeDom.Compiler
  open System.IO
  open System.Linq
  open System.Text
  open System.Web.Razor

</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<h3>Helpers &amp; Setup</h3>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<p>In F#, literate means bottom up. You have to define what you want to use
before you use it. Therefore, we start with the helpers and setup
then get into the more meaty generation.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_5">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_5">&#182;</a>
							</div>
							<p>The language type stores each supported language,
as well as regex matchers to determine whether or not
a given file matches a supported language.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  type Language = {
    Name : string
    Singleline : string
    MultilineStart : string option
    MultilineEnd : string option
    XmlDoc : string option } with
    member x.CommentMatcher =
      RegularExpressions.Regex(@&quot;^\s*&quot; + x.Singleline + @&quot;\s?&quot;)
    member x.CommentFilter =
      let baseRegex = @&quot;^#![/]|^\s*#\{&quot;
      let matchRegex =
        match x.XmlDoc with
        | Some v -&gt; baseRegex + @&quot;|^\s*&quot; + v
        | _ -&gt; baseRegex
      RegularExpressions.Regex(sprintf &quot;(%s)&quot; matchRegex)
    member x.IsMatch(line) =
      x.CommentMatcher.IsMatch(line) &amp;&amp; not (x.CommentFilter.IsMatch(line))
  
</code></pre>
						</td>
					</tr>
					<tr id="section_6">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_6">&#182;</a>
							</div>
							<p>The section stores the various sections of a file's generated markup.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  type Section = {
    CodeHtml : string
    DocsHtml : string }
  
</code></pre>
						</td>
					</tr>
					<tr id="section_7">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_7">&#182;</a>
							</div>
							<p>The template base class for the rendering via Razor.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  [&lt;AbstractClass&gt;]
  type TemplateBase() =
    let mutable buffer = new StringBuilder()
    let mutable title : string = null
    let mutable pathToCss : string = null
    let mutable getSourcePath : Func&lt;string,string&gt; = null
    let mutable sections : Section[] = null
    let mutable sources : string[] = null
    member x.Buffer
      with get() = buffer
      and  set(value) = buffer &lt;- value
    member x.Title
      with get() = title
      and  set(value) = title &lt;- value
    member x.PathToCss
      with get() = pathToCss
      and  set(value) = pathToCss &lt;- value
    member x.GetSourcePath
      with get() = getSourcePath
      and  set(value) = getSourcePath &lt;- value
    member x.Sections
      with get() = sections
      and  set(value) = sections &lt;- value
    member x.Sources
      with get() = sources
      and  set(value) = sources &lt;- value
    abstract Execute : unit -&gt; unit
    abstract WriteLiteral : obj -&gt; unit
    default x.WriteLiteral(value) = x.Buffer.Append(value) |&gt; ignore
    abstract Write : obj -&gt; unit
    default x.Write(value) = x.WriteLiteral(value)
  
</code></pre>
						</td>
					</tr>
					<tr id="section_8">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_8">&#182;</a>
							</div>
							<p>A list of the languages that Focco supports, mapping the file extension to
the symbol that indicates a comment. To add another language to Focco's
repertoire, add it here. (Support for multiline comments is coming.)</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  let private languages =
    [| (&quot;.js&quot;,  { Name = &quot;javascript&quot;
                  Singleline = &quot;//&quot;
                  MultilineStart = Some &quot;/*&quot;
                  MultilineEnd = Some &quot;*/&quot;
                  XmlDoc = None })
       (&quot;.fs&quot;,  { Name = &quot;fsharp&quot;
                  Singleline = &quot;//&quot;
                  MultilineStart = Some &quot;(*&quot;
                  MultilineEnd = Some &quot;*)&quot;
                  XmlDoc = Some &quot;///&quot; })
       (&quot;.cs&quot;,  { Name = &quot;csharp&quot;
                  Singleline = &quot;//&quot;
                  MultilineStart = Some &quot;/*&quot;
                  MultilineEnd = Some &quot;*/&quot;
                  XmlDoc = Some &quot;///&quot; })
       (&quot;.vb&quot;,  { Name = &quot;vb.net&quot;
                  Singleline = &quot;&#39;&quot;
                  MultilineStart = None
                  MultilineEnd = None
                  XmlDoc = Some &quot;&#39;&#39;&#39;&quot; })
       (&quot;.sql&quot;, { Name = &quot;sql&quot;
                  Singleline = &quot;--&quot;
                  MultilineStart = None
                  MultilineEnd = None
                  XmlDoc = None }) |]
    |&gt; dict
  
  let private executingDirectory =
    Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location)

</code></pre>
						</td>
					</tr>
					<tr id="section_9">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_9">&#182;</a>
							</div>
							<p>Setup the Razor templating engine so that we can quickly pass the data in
and generate HTML.</p>

<p>The file <code>Resources\Focco.cshtml</code> is read and compiled into a new dll
with a type that extends the <code>TemplateBase</code> class. This new assembly is
loaded so that we can create an instance and pass data into it
and generate the HTML.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  let private getTemplateType() =
    let host = RazorEngineHost(CSharpRazorCodeLanguage())
    host.DefaultBaseClass &lt;- typeof&lt;TemplateBase&gt;.FullName
    host.DefaultNamespace &lt;- &quot;RazorOutput&quot;
    host.DefaultClassName &lt;- &quot;Template&quot;
    host.NamespaceImports.Add(&quot;System&quot;) |&gt; ignore
  
    use reader = new StreamReader(Path.Combine(executingDirectory, &quot;Resources&quot;, &quot;Focco.cshtml&quot;))
    let razorResult = RazorTemplateEngine(host).GenerateCode(reader)
  
    let compilerParams =
      CompilerParameters(
        GenerateInMemory = true,
        GenerateExecutable = false,
        IncludeDebugInformation = false,
        CompilerOptions = &quot;/target:library /optimize&quot;)
    compilerParams.ReferencedAssemblies.
      Add(typeof&lt;TemplateBase&gt;.Assembly.CodeBase.Replace(&quot;file:///&quot;,&quot;&quot;).Replace(&quot;/&quot;,&quot;\\&quot;)) |&gt; ignore
  
    let codeProvider = new Microsoft.CSharp.CSharpCodeProvider()
    let results = codeProvider.CompileAssemblyFromDom(compilerParams, razorResult.GeneratedCode)
  
</code></pre>
						</td>
					</tr>
					<tr id="section_10">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_10">&#182;</a>
							</div>
							<p>Check for errors that may have occurred during template generation.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>    if results.Errors.HasErrors then
      results.Errors.OfType&lt;CompilerError&gt;()
      |&gt; Seq.filter (fun x -&gt; not x.IsWarning)
      |&gt; Seq.iter (fun x -&gt; printfn &quot;Error compiling template: (%d, %d) %s&quot; x.Line x.Column x.ErrorText)
  
    results.CompiledAssembly.GetType(&quot;RazorOutput.Template&quot;)
  
</code></pre>
						</td>
					</tr>
					<tr id="section_11">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_11">&#182;</a>
							</div>
							<p>Get the current language we're documenting, based on the extension.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  let private getLanguage source =
    let extension = Path.GetExtension source
    if languages.ContainsKey(extension)
      then languages.[extension]
      else Unchecked.defaultof&lt;Language&gt;
  
</code></pre>
						</td>
					</tr>
					<tr id="section_12">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_12">&#182;</a>
							</div>
							<p>Given a string of source code, parse out each comment and the code that
follows it, and create an individual <code>Section</code> for it.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  let private parse source lines =
    let language = getLanguage(source)
    let save docsText codeText sections =
      { DocsHtml = docsText.ToString()
        CodeHtml = codeText.ToString() }
      :: sections
    let sections, _, docsText, codeText =
      lines |&gt; Seq.fold (fun state line -&gt;
        let sections, hasCode, docsText, codeText = state
        if language.IsMatch(line) then
          if hasCode then
            let sections&#39; = sections |&gt; save docsText codeText
            let docsText&#39; =
              let sb = StringBuilder()
              in sb.AppendLine(language.CommentMatcher.Replace(line,&quot;&quot;))
            (sections&#39;, false, docsText&#39;, new StringBuilder())
          else
            (sections, hasCode, docsText.AppendLine(language.CommentMatcher.Replace(line, &quot;&quot;)), codeText)
        elif language.CommentFilter.IsMatch(line) then (sections, true, docsText, codeText)
        else (sections, true, docsText, codeText.AppendLine(line)))
        ([], false, StringBuilder(), StringBuilder())
    sections |&gt; save docsText codeText |&gt; List.rev
  
</code></pre>
						</td>
					</tr>
					<tr id="section_13">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_13">&#182;</a>
							</div>
							<p>Prepares a single chunk of code for HTML output and runs the text of its
corresponding comment through <strong>Markdown</strong>, using a C# implementation
called <a href="http://code.google.com/p/markdownsharp/">MarkdownSharp</a>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  let private highlight source sections =
    let markdown = MarkdownSharp.Markdown()
    sections |&gt; Seq.map (fun section -&gt;
      { section with
          DocsHtml = markdown.Transform(section.DocsHtml)
          CodeHtml = System.Web.HttpUtility.HtmlEncode(section.CodeHtml) })
  
</code></pre>
						</td>
					</tr>
					<tr id="section_14">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_14">&#182;</a>
							</div>
							<p>Compute the destination HTML path for an input source file path. If the source
is <code>Example.cs</code>, the HTML will be at <code>docs/example.html</code></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  let private getDestination filepath =
    let directories =
      Path.GetDirectoryName(filepath)
        .Substring(1)
        .Split([| Path.DirectorySeparatorChar |], StringSplitOptions.RemoveEmptyEntries)
    let depth = directories.Length
    let destination =
      Path.Combine(&quot;docs&quot;, String.Join(Path.DirectorySeparatorChar.ToString(), directories)).ToLower()
    Directory.CreateDirectory(destination) |&gt; ignore
    Path.Combine(&quot;docs&quot;, Path.ChangeExtension(filepath, &quot;html&quot;).ToLower()), depth
  
</code></pre>
						</td>
					</tr>
					<tr id="section_15">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_15">&#182;</a>
							</div>
							<h3>Main Documentation Generation Functions</h3>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  
</code></pre>
						</td>
					</tr>
					<tr id="section_16">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_16">&#182;</a>
							</div>
							<p>Once all of the code is finished highlighting, we can generate the HTML file
and write out the documentation. Pass the completed sections into the template
found in <code>Resources/Focco.cshtml</code></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  let private generateHtml source files sections =
    let destination, depth = getDestination source
    let pathToRoot = List.fold (fun pathToRoot _ -&gt; Path.Combine(&quot;..&quot;, pathToRoot)) &quot;&quot; [0..(depth-1)]
  
    let templateType = getTemplateType()
    let htmlTemplate = Activator.CreateInstance(templateType) :?&gt; TemplateBase

    htmlTemplate.Title &lt;- Path.GetFileName(source)
    htmlTemplate.PathToCss &lt;- Path.Combine(pathToRoot, &quot;focco.css&quot;).Replace(&#39;\\&#39;, &#39;/&#39;)
    htmlTemplate.Sections &lt;- sections |&gt; Array.ofSeq
    htmlTemplate.Sources &lt;- files |&gt; Array.ofSeq
    htmlTemplate.GetSourcePath &lt;- Func&lt;_,_&gt;(fun s -&gt;
      Path.Combine(pathToRoot, Path.ChangeExtension(s.ToLower(), &quot;.html&quot;).Substring(2)).Replace(&#39;\\&#39;, &#39;/&#39;))
  
    htmlTemplate.Execute()
    File.WriteAllText(destination, htmlTemplate.Buffer.ToString())
  
</code></pre>
						</td>
					</tr>
					<tr id="section_17">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_17">&#182;</a>
							</div>
							<p>Generate the documentation for a source file by reading it in, splitting it
up into comment/code sections, highlighting them for the appropriate language,
and merging them into an HTML template.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  let private generateDocumentation files source =
    File.ReadAllLines source
    |&gt; parse source
    |&gt; highlight source
    |&gt; generateHtml source files
  
</code></pre>
						</td>
					</tr>
					<tr id="section_18">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_18">&#182;</a>
							</div>
							<p>Find all the files that match the pattern(s) passed in as arguments and
generate documentation for each one.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>  let generate (targets:string[]) =
    if targets.Length &lt;= 0 then
      failwith &quot;At least one target must be specified&quot;
    else
      Directory.CreateDirectory(&quot;docs&quot;) |&gt; ignore
      File.Copy(sourceFileName = Path.Combine(executingDirectory, &quot;Resources&quot;, &quot;Focco.css&quot;),
                destFileName = Path.Combine(&quot;docs&quot;, &quot;focco.css&quot;),
                overwrite = true)
      File.Copy(sourceFileName = Path.Combine(executingDirectory, &quot;Resources&quot;, &quot;prettify.js&quot;),
                destFileName = Path.Combine(&quot;docs&quot;, &quot;prettify.js&quot;),
                overwrite = true)
      let files =
        [ for target in targets do
            yield! Directory.GetFiles(&quot;.&quot;, target, SearchOption.AllDirectories)
                   |&gt; Seq.filter (fun filename -&gt;
                      not (getLanguage(Path.GetFileName(filename)) = Unchecked.defaultof&lt;Language&gt;)) ]
      for file in files do generateDocumentation files file

</code></pre>
						</td>
					</tr>
					<tr id="section_19">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_19">&#182;</a>
							</div>
							<p>The program entry point.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>[&lt;EntryPoint&gt;]
let main args =
  if not (args.Length &gt; 0) then
    printfn &quot;Run focco with a filename or path with file extension, e.g. `focco.exe src\\*.fs`.&quot;
  else Focco.generate args
  0

</code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>
